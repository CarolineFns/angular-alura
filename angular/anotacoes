npm install -g @angular/cli
ng new alurapic
ng --version
cd alurapic
ng serve --open

-------------
ERROR in node_modules/rxjs
npm install rxjs@6.0.0 --save
-------------

- Angular utiliza a linguagem typescript
- localhost:4200
- tudo é um componente em angular, que guarda: 
comportamento, o CSS, e a marcação HTML, a estrutura, em um único local
- @Component, Decorator que torna a classe um componente
- metainformação
- selector: 'app-root' ---   <app-root></app-root>
- selector nos permite utilizar o componente em templates em sua forma declarativa, 
então, todo o conteúdo de app.component.ts, sua apresentação, o que ele faz, 
seu CSS, são acessados por meio dele.
- Angular utiliza um webpack, um module bundle, isto é, um empacotador de módulos famoso, 
utilizado por Create React App, Vue CLI, e outros frameworks Single Page Application.  
Mas nenhum momento estas configurações do webpack são exibidas, 
pois elas ficam encapsuladas pelo Angular CLI.

- {{ title }} -> Angular expression (AE) e dentro expressão
- Data binding, ou "associação de dados"
- One way data binding ("data binding unidirecional")
- Quando formos realizar Data binding com atributos HTML do nosso component, 
usaremos os colchetes. E quando formos exibir um valor em uma tag, ou isoladamente, 
usaremos uma Angular Expression.
- Utilizamos {{ }} dentro de tags e [ ] para atributos
- menubar.component.ts -> MenubarComponent
- https://angular.io/

- npm install bootstrap@4.1.1
- angular.json
"styles": [
    "src/styles.css",
    "./node_modules/bootstrap/dist/css/bootstrap.min.css"
],
"scripts": []
- <img class="img-thumbnail" [src]="url" [alt]="title">

- um componente obrigatoriamente precisa fazer parte de um módulo.
- O módulo, é uma forma de organizarmos a nossa aplicação
- app.module.ts é o primeiro módulo a ser carregado
- <ap-photo url="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2d/Lioness_Etosha_NP.jpg/500px-Lioness_Etosha_NP.jpg" description="Leoa"></ap-photo>
- @Input() -> receber um parâmetro externo, passando um valor por meio da forma declarativa do componente
- Inbound properties, ou seja, aceitam receber um valor por meio de sua forma declarativa.

- feature module
- @NgModule
@NgModule({
    declarations: [ PhotoComponent ],
    exports: [ PhotoComponent ]
})
<ap-photo
    *ngFor="let photo of photos"
    [url]="photo.url"
    [description]="photo.description"
>
</ap-photo>

- npm install
- npm start
- Web API - servidor que tem a responsabilidade de 
fornecer os dados para a aplicação Angular em uma Single Page Application
- import { HttpClientModule } from '@angular/common/http';

- ao criarmos um serviço, usamos @Injectable(),
indica que a classe é injetável, ou seja, pode receber HttpClient e outros.

- http
    .get<Object[]>('http://localhost:3000/flavio/photos')
    .subscribe(photos => this.photos = photos);
- @Injectable({ providedIn: 'root' }) -> configuracao pra indicar um escopo raiz
- "Rename Symbol"

- constructor(private photoService: PhotoService){}
- ngOnInit(): void {}
- export class AppComponent implements OnInit 

- configuracao pra import de aspas simples
"javascript.preferences.quoteStyle":"single",
"typescript.preferences.quoteStyle": "single"

- ng generate component photos/photo-list

- CommonModule é uma boa prática importar em todos os modules pois
importa as diretrizas do angular como *ngFor e outras, disponíveis.
- O CommonModule possui todas as diretivas básicas como NgIf, NgFor, NgForOf etc
- O BrowserModule só deve ser importado no modulo principal da aplicação.
- O BrowserModule possui funcionalidades essenciais para rodar e iniciar a aplicação.

- RouterModule
- AppRoutingModule
- import { AppRoutingModule } from './app.routing.module';
const routes: Routes = [
    { path: 'user/flavio', component: PhotoListComponent },
    { path: 'p/add', component: PhotoFormComponent }
];

@NgModule({
    imports: [
        RouterModule.forRoot(routes)
    ],
    exports: [ RouterModule ]
})

 Sendo nossa aplicação localhost:4200, tudo o que for 4200/ 
 terá relação com a rota raiz. Então, o resultado de forRoot() 
 será importado, e levará em consideração esta lista de rotas (RouterModule).

 - ng generate module errors
 - ng generate component errors/not-found
 - { path: '**', component: NotFoundComponent }
 -     { path: 'user/:userName', component: PhotoListComponent },
 - const userName = this.activatedRoute.snapshot.params.userName;
 - private activatedRoute: ActivatedRoute

<ol class="list-unstyled row">
    <li *ngFor="let cols of rows" class="row">
        <div *ngFor="let photo of cols" class="col-4">
            <ap-photo
                [url]="photo.url"
                [description]="photo.description">
            </ap-photo>
        </div>
    </li>
</ol>

groupColumns(photos: Photo[]){
    const newRows = [];
      for(let index = 0; index < photos.length; index+=3){
        newRows.push( photos.slice(index, index + 3));
      }
      return newRows;
  }

- OnChanges
- ngOnChanges
- Um objeto do tipo SimpleChanges possui uma propriedade de 
mesmo nome da inbound property que sofreu mudança.
- O método ngOnChanges, quando chamado pelo próprio framework, 
recebe como parâmetro uma instância de SimpleChanges
- if(changes.photos)

<div class="text-center mt-3 mb-3">
    <form>
        <input
            class="rounded"
            type="search"
            placeholder="search..."
            autofocus
            (keyup)="filter = $event.target.value"
            >
    </form>
</div>
{{ filter }}
<ap-photos [photos]="photos"></ap-photos>

- mt-3 margin top 
- mb-3 margin bottom

- Event binding -> ()

unidirecional
[] -> data binding -> componente para o template
() -> event binding -> view para o componente

- Pipes -> podem gerar transformações nos dados, e podemos criar os nossos. 
- {{ nome | uppercase }}
- <ap-photos [photos]="photos | filterByDescription: filter"></ap-photos>
export class FilterByDescrition implements PipeTransform{
    transform(photos: Photo[], descriptionQuery: string){
        descriptionQuery = descriptionQuery
            .trim()
            .toLowerCase();

        if(descriptionQuery)
            return photos.filter(
                photo => photo.description
                    .toLowerCase()
                    .includes(descriptionQuery));
        else
            return photos;
    }
}
<p class="text-center text-muted" *ngIf="!photos.length">

- PhotoListResolver
- é necessário configurar o Resolver na rota correspondente da aplicação.
- this.photos = this.activatedRoute.snapshot.data['photos'];
- const routes: Routes = [
    { 
        path: 'user/:userName', 
        component: PhotoListComponent,
        resolve: {
            photos: PhotoListResolver
        }
     },
];

- resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<Photo[]>  {
        return this.service.listFromUser(route.params.userName);}

- export class PhotoListResolver implements Resolve<Observable<Photo[]>>{

- Subject -> pode-ser emitir um valor e escutá-lo
- debounce: Subject<string> = new Subject<string>();
- import { debounceTime } from 'rxjs/operators';
- this.debounce.pipe(debounceTime(300)).subscribe(filter => this.filter = filter);
- this.debounce.unsubscribe();
- (keyup)="debounce.next($event.target.value)"
- Lettable operators
